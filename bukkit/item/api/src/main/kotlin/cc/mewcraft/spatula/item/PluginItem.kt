package cc.mewcraft.spatula.item

import org.bukkit.entity.Player
import org.bukkit.inventory.ItemStack

/**
 * An abstract representation of a custom item from an external plugin.
 *
 * @param T the type of Plugin Item
 * */
abstract class PluginItem<T>
protected constructor() {
    @get:JvmSynthetic
    @set:JvmSynthetic
    internal var _pluginId: String? = null
        set(value) {
            field = value?.lowercase()
        }

    @get:JvmSynthetic
    @set:JvmSynthetic
    internal var _itemId: String? = null
        set(value) {
            field = value?.lowercase()
        }

    /**
     * _Plugin Identifier_ of this item, in lowercase.
     * It is usually the plugin name but in lowercase.
     */
    val pluginId: String
        get() = checkNotNull(_pluginId) { "The property `pluginId` is not initialized" }

    /**
     * _Item Identifier_ of this item, in lowercase.
     * The format of it is implementation-defined.
     */
    val itemId: String
        get() = checkNotNull(_itemId) { "The property `itemId` is not initialized" }

    /**
     * _Config Reference_ of this item, in lowercase.
     * The string is generated by concatenating [pluginId] and [itemId], split by a semicolon.
     * An example format is `[pluginId]:[itemId]`.
     */
    val reference: String
        get() = "$pluginId:$itemId"

    /**
     * Creates an ItemStack from this item.
     *
     * @return the ItemStack generated from this item
     */
    abstract fun createItemStack(): ItemStack?

    /**
     * Creates an ItemStack from this item.
     *
     * @return the ItemStack generated from this item, possibly varying on the specific [player]
     */
    abstract fun createItemStack(player: Player): ItemStack?

    /**
     * Checks whether [itemStack] **is** this item.
     *
     * @return `true` if [itemStack] matches the backed plugin, otherwise false
     */
    abstract fun matches(itemStack: ItemStack): Boolean

    /**
     * Checks whether [itemStack] is from the backed plugin.
     *
     * @return `true` if [itemStack] is from the backed plugin, otherwise false
     */
    abstract fun belongs(itemStack: ItemStack): Boolean

    /**
     * Tries to get the [itemId] from [itemStack].
     *
     * @return the [itemId] from [itemStack] or `null`, if the [itemStack] is not a custom item from plugins
     */
    abstract fun asItemId(itemStack: ItemStack): String?

    /**
     * True if the backed plugin is loaded, otherwise false.
     */
    abstract val isLoaded: Boolean

    /**
     * Internal instance of this item from the backed plugin.
     *
     * Usually, the custom items from plugins have their own representation classes.
     * This property returns the internal instance from the backed plugin,
     * which might be useful in some cases.
     *
     * **Implementation Notes**
     * It is expected to use [pluginId] and [itemId] to get the internal instance from the backed plugin.
     */
    protected val internalInstance: T?
        get() {
            val supplier = internalInstanceSupplier()
            if (supplier == null) {
                logger.error("Cannot find an internal instance for item identifier `$itemId`")
            }
            return supplier
        }

    protected abstract val internalInstanceSupplier: () -> T?
}

/* Extension functions of ItemStack */

fun ItemStack.matches(pluginItem: PluginItem<*>): Boolean =
    pluginItem.matches(this)

fun ItemStack.belongs(pluginItem: PluginItem<*>): Boolean =
    pluginItem.belongs(this)

fun ItemStack.asItemId(pluginItem: PluginItem<*>): String? =
    pluginItem.asItemId(this)
